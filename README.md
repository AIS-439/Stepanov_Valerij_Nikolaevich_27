# Паттерны проектирования в администрировании и разработке: Repository, Service Layer, Data Transfer Object (DTO)

## Содержание

[1 Введение ](#1-введение)

[2 Теоретические основы и контекст](#2-теоретические-основы-и-контекст)

    [2.1 Понятие паттерна проектирования и назначение](#21-понятие-паттерна-проектирования-и-назначение)

    [2.2 Классификация](#22-классификация)

    [2.3 Принципы SOLID, связанные с темой (SRP, DIP)](#23-принципы-solid-связанные-с-темой-srp-dip)

    [2.4 Слоистая архитектура и «границы приложения»](#24-слоистая-архитектура-и-границы-приложения)

[3 Паттерн Repository](#3-паттерн-repository)

    [3.1 Определение и назначение паттерна](#31-определение-и-назначение-паттерна)

    [3.2 Типовые обязанности репозитория](#32-типовые-обязанности-репозитория)

    [3.3 Преимущества для разработки](#33-преимущества-для-разработки)

    [3.4 Преимущества для администрирования и эксплуатации](#34-преимущества-для-администрирования-и-эксплуатации)

    [3.5 Недостатки и типовые ошибки](#35-недостатки-и-типовые-ошибки)

[4 Service Layer](#4-service-layer)

    [4.1 Определение и роль](#41-определение-и-роль)

    [4.2 Границы ответственности](#42-границы-ответственности)

    [4.3 Преимущества для разработки](#43-преимущества-для-разработки-1)

    [4.4 Преимущества для администрирования](#44-преимущества-для-администрирования)

    [4.5 Недостатки и антипаттерны](#45-недостатки-и-антипаттерны)

[5 DTO (Data Transfer Object)](#5-dto-data-transfer-object)

    [5.1 Определение и назначение](#51-определение-и-назначение)

    [5.2 DTO на границах](#52-dto-на-границах)

    [5.3 Маппинг DTO и доменная модель (Mapper/Assembler)](#53-маппинг-dto-и-доменная-модель-mapperassembler)

    [5.4 Преимущества для администрирования и эксплуатации](#54-преимущества-для-администрирования-и-эксплуатации-1)

    [5.5 Риски DTO](#55-риски-dto)

[6 Совместное применение паттернов (FastAPI + SQLAlchemy)](#6-совместное-применение-паттернов-fastapi-sqlalchemy)

    [6.1 Сквозной сценарий](#61-сквозной-сценарий)

    [6.2 Поток: от Controller/API к выходной DTO](#62-поток-от-controllerapi-к-выходной-dto)

    [6.3 Границы ответственности и критерии выбора](#63-границы-ответственности-и-критерии-выбора)

[7 Заключение](#7-заключение)

[8 Список литературы](#8-список-литературы)

## 1 Введение

В современных информационных системах (веб‑приложениях, микросервисах, корпоративных платформах) усложнение бизнес‑логики и рост числа интеграций приводят к тому, что ключевым фактором качества становится архитектурная дисциплина: код должен оставаться понятным, тестируемым и удобным для сопровождения в эксплуатации. На практике проблемы часто проявляются одинаково: логика «размазана» по контроллерам и моделям, доступ к данным смешан с правилами предметной области, а форматы обмена данными меняются стихийно, нарушая обратную совместимость клиентов и интеграций. Эти риски усиливаются по мере роста команды и числа релизов, поэтому особенно востребованы устойчивые архитектурные решения, которые задают явные границы ответственности между слоями приложения.

Одним из распространённых подходов к наведению порядка в приложении является использование набора взаимодополняющих паттернов: Repository, Service Layer и Data Transfer Object (DTO). Repository вводится как абстракция доступа к данным, Service Layer – как слой прикладных операций (use cases), который координирует выполнение сценариев и взаимодействие с инфраструктурой, а DTO применяется для безопасной и устойчивой передачи данных между слоями и/или по сети. В совокупности эти паттерны позволяют уменьшить связанность компонентов, повысить предсказуемость изменений и упростить тестирование ключевых сценариев.

Цель данного реферата – выполнить обзор и анализ паттернов Repository, Service Layer и DTO в контексте разработки и администрирования (эксплуатации) информационных систем, а также показать, как их совместное применение влияет на качество архитектуры и поддержку приложения.

Для достижения поставленной цели необходимо решить следующие задачи:

- Описать назначение и принципы работы паттернов Repository, Service Layer и DTO.

- Показать типовую схему взаимодействия между слоями (например: API/контроллер → DTO → Service Layer → Repository → DTO) и объяснить распределение ответственности.

- Проанализировать преимущества и недостатки каждого подхода с точки зрения сопровождаемости, тестируемости и эксплуатационной управляемости.

- Рассмотреть типовые ошибки и антипаттерны применения (например, чрезмерная логика в репозиториях, «перегруженный» сервисный слой, неконтролируемое разрастание DTO).

Объектом исследования является архитектура прикладных информационных систем и процессы их разработки и сопровождения. Предметом исследования выступают методы структурирования кода и контрактов взаимодействия между слоями с помощью паттернов Repository, Service Layer и DTO.

## 2 Теоретические основы и контекст

### 2.1 Понятие паттерна проектирования и назначение

Паттерн (шаблон) проектирования - это типовое, многократно используемое решение повторяющейся проблемы проектирования в программных системах.

Его назначение – не «готовый код», а описание структуры и ролей компонентов, которое помогает снижать сложность, улучшать читаемость и ускорять принятие архитектурных решений в команде.

Паттерны особенно полезны в ситуациях, когда система развивается итеративно: появляется много сценариев, интеграций и изменений, и без единых подходов код быстро теряет целостность.

### 2.2 Классификация

На практике удобно различать несколько «уровней» типовых решений: архитектурные паттерны (уровень структуры системы), паттерны проектирования (уровень взаимодействия классов/компонентов) и идиомы (уровень конкретного языка и его выразительных средств).

Архитектурные паттерны (или архитектурные стили/подходы) задают общую организацию приложения: какие крупные части существуют, как они взаимодействуют, где проходят границы ответственности и зависимости.

Паттерны проектирования обычно описывают более локальные решения: например, как вынести доступ к данным в отдельный компонент (Repository) или как оформить прикладные операции в сервисах (Service Layer) так, чтобы изолировать доменную/прикладную логику от деталей инфраструктуры.

Идиомы зависят от конкретного языка (Python/Java/C#/PHP и т.д.) и представляют собой «принятый способ» выразить решение средствами языка: соглашения по интерфейсам, типам, исключениям, сериализации, аннотациям и т.п.

Для темы данного реферата важна связка уровней: Repository и Service Layer часто рассматриваются как паттерны проектирования и одновременно как практики, поддерживающие выбранную архитектуру (например, слоистую или Clean/Onion).

### 2.3 Принципы SOLID, связанные с темой (SRP, DIP)

Принципы SOLID – это набор рекомендаций объектно‑ориентированного проектирования, направленных на снижение связанности и повышение расширяемости кода.

SRP (Single Responsibility Principle) формулируется как требование, чтобы у модуля/класса была одна ответственность (одна причина для изменения), что напрямую поддерживает идею разделения на слои и роли.

В контексте Repository/Service Layer/DTO SRP помогает избежать смешивания обязанностей: доступ к данным не «утекает» в контроллеры и доменные объекты, прикладные сценарии не расползаются по инфраструктурным классам, а транспортные модели (DTO) не начинают заменять доменную модель.

DIP (Dependency Inversion Principle) требует, чтобы высокоуровневые модули зависели от абстракций, а не от деталей, и чтобы детали зависели от абстракций.

Практический смысл DIP для данной темы – возможность строить сервисный слой и доменную логику поверх интерфейсов репозиториев и портов интеграций, упрощая тестирование (подмену реализаций) и снижая привязку к конкретной БД/ORM/внешнему API.

### 2.4 Слоистая архитектура и «границы приложения»

Слоистая архитектура предполагает разделение системы на уровни (например, интерфейс/доставка запросов, прикладная логика, доменная модель, инфраструктура), чтобы изменения локализовывались внутри соответствующего слоя и не ломали остальные части.

Под «границей приложения» в данной работе понимаются точки, где система взаимодействует с внешним миром: HTTP API, входные/выходные контракты, интеграции с другими сервисами, брокерами сообщений и хранилищами.

На границах особенно важны контракты данных (часто в форме DTO), потому что они фиксируют формат обмена и позволяют отделить внешний интерфейс от внутренних моделей и логики.

Service Layer в таком подходе выступает как прикладной «фасад» набора операций (use cases), через который внешние адаптеры (контроллеры, обработчики сообщений, CLI‑команды) инициируют выполнение сценариев.

Repository, в свою очередь, помогает удерживать инфраструктурные детали хранения данных за внутренней границей слоя доступа к данным, предоставляя прикладной логике стабильный интерфейс для работы с сущностями/агрегатами.

## 3  Паттерн Repository

### 3.1 Определение и назначение паттерна

Repository (репозиторий) - это паттерн, который выделяет отдельный слой/компонент для работы с данными и предоставляет приложению понятный интерфейс доступа к ним, скрывая детали конкретного механизма хранения (SQL/ORM/внешний источник).

Его назначение – отделить бизнес‑логику и прикладные сценарии от инфраструктурных деталей (таблиц, запросов, драйверов), чтобы укаждого слоя была более чёткая ответственность и ниже связанность.

### 3.2 Типовые обязанности репозитория

К типовым обязанностям репозитория относят операции создания/чтения/обновления/удаления (CRUD), а также выборки по критериям (поиск, фильтрация, сортировка, пагинация).

В моделях, где используются агрегаты (в духе DDD), репозиторий часто выступает «точкой загрузки и сохранения» агрегата как целого, чтобы поддерживать целостность и инварианты на уровне доменной модели.

Также репозиторий обычно инкапсулирует детали доступа: формирование запросов, маппинг между доменными объектами и схемой хранения, обработку ошибок доступа к данным.

### 3.3 Преимущества для разработки

Репозиторий помогает изолировать код приложения от конкретной БД/ORM, поэтому смена технологии хранения или оптимизация запросов реже требует правок бизнес‑логики и API‑слоя.

Появляется удобная точка для модульного тестирования: прикладной/сервисный слой можно тестировать, подменяя репозиторий на фейк/мок и проверяя сценарии без реальной базы. Дополнительно уменьшается «сцепление» между слоями: контроллеры и сервисы зависят от интерфейса репозитория, а не от деталей ORM и SQL.

### 3.4 Преимущества для администрирования и эксплуатации

С точки зрения эксплуатации наличие репозитория упрощает контролируемые изменения в доступе к данным: например, перенос на другой тип хранилища, добавление кэширования или ретраев можно централизовать в одном слое, не переписывая всю прикладную логику.

Репозиторий также удобен как единая точка для внедрения сквозных эксплуатационных требований: аудит изменений (кто/что/когда изменил), техническое логирование SQL‑ошибок, метрики времени ответа хранилища.

При миграциях и изменениях схемы данных легче локализовать правки в реализациях репозитория/маппинге, сохранив стабильные интерфейсы для верхних уровней приложения.

### 3.5 Недостатки и типовые ошибки

Одна из частых ошибок – «утечка» деталей ORM наружу. Суть ошибки в том, что репозиторий перестаёт быть «границей» слоя доступа к данным и начинает отдавать наружу объекты/типы, привязанные к конкретной ORM (например, IQueryable, QuerySet, ORM‑Entity, ORM‑Session/UnitOfWork). Тогда верхние слои (Service Layer, контроллеры) неявно зависят от поведения ORM: ленивой загрузки, жизненного цикла сессии/контекста, особенностей трекинга изменений, специфичных методов фильтрации и т.п., что снижает переносимость и усложняет тестирование. Типичный признак - когда бизнес‑код «вынужден» знать, в каком месте уже открыта сессия и можно ли обращаться к навигационным свойствам, иначе появляются ошибки вида “session closed / lazy initialization”. Практическое правило: репозиторий должен возвращать понятные доменные объекты (или специально выделенные модели чтения), а не «строитель запросов» как публичный контракт, чтобы внешний код не конструировал запросы напрямую поверх ORM.

Ещё одна проблема - N+1. N+1 возникает, когда приложение сначала делает один запрос за списком сущностей (это «1»), а затем для каждой сущности выполняет ещё по одному запросу за связанными данными (это «N»), получая в сумме N+1 обращений к базе. Чаще всего это проявляется при комбинации «получили список» + «дальше в цикле читаем связанный объект/коллекцию», которая триггерит ленивую загрузку для каждого элемента. Последствия - резкое падение производительности и непредсказуемое время ответа: на тестовых данных проблема может быть незаметна, но на реальных объёмах превращается в узкое место. Типовой путь решения - явная стратегия загрузки связей: например, eager loading (предзагрузка) вместо неконтролируемого lazy loading, чтобы нужные данные вытаскивались ограниченным числом запросов.

Наконец, встречается «слишком умный» репозиторий. Репозиторий становится «слишком умным», когда в него помещают бизнес‑правила и оркестрацию сценариев (проверки прав, расчёты, сложные ветвления, вызовы внешних сервисов), из‑за чего он превращается в смесь слоя данных и прикладной логики. В таком случае размываются границы ответственности: вместо чёткого разделения «репозиторий – данные, сервис – сценарии» появляется монолитный класс, который сложно переиспользовать, тестировать и менять без побочных эффектов. Дополнительный симптом – «универсальные методы на все случаи» (много параметров фильтрации/выборки), которые делают публичный API репозитория расплывчатым и провоцируют хаотичное использование.

Набор практических критериев:

- Репозиторий не должен «торчать наружу» типами ORM (например, публичным Query()/IQueryable) - иначе слой данных фактически протекает в бизнес‑код.

- Если в профайлере видно «много однотипных запросов на связи» – это сигнал N+1 и повод пересмотреть стратегию загрузки данных.

- Если в репозитории появились бизнес‑решения уровня “можно ли купить”, “какая скидка”, “какое состояние заказа допустимо” – ответственность съехала из Service Layer/домена в слой данных.

## 4 Service Layer

### 4.1 Определение и роль

Service Layer (сервисный слой) – это слой, который задаёт набор операций приложения (application services) и предоставляет внешним клиентам согласованный интерфейс для выполнения прикладных сценариев.

Его роль – координировать выполнение бизнес‑операций и взаимодействие между компонентами (например, репозиториями, доменными объектами и инфраструктурой), не смешивая эту координацию с транспортным слоем (контроллерами) и деталями хранения данных.

### 4.2 Границы ответственности

Сервисный слой отвечает за оркестрацию use-case: какие шаги выполнить, в каком порядке, какие зависимости задействовать и какой результат вернуть наружу. Также он часто становится местом управления сквозными аспектами выполнения сценариев – например, транзакционными границами и согласованностью вызовов нескольких репозиториев в рамках одной операции. Дополнительно на уровне Service Layer удобно централизовать политики доступа, валидацию входных данных (на уровне сценария) и интеграции с внешними системами (очереди, почта, сторонние API), оставляя доменной модели чистые бизнес‑правила.

### 4.3 Преимущества для разработки

Service Layer позволяет держать контроллеры «тонкими»: контроллер в основном решает задачи транспорта (принять HTTP‑запрос или CLI‑команду, распарсить входные данные, вернуть ответ), а выполнение прикладного сценария делегирует сервису. Это снижает связанность контроллеров с бизнес‑логикой и делает код сценариев более заметным и единообразным, потому что они сосредоточены в одном месте – в методах сервисного слоя.

Дополнительное преимущество – упрощение тестирования и изменений: use-case можно проверять на уровне сервиса, подменяя зависимости (например, репозитории и интеграции), без необходимости прогонять сценарий через конкретный транспортный слой (HTTP/очередь/CLI). Благодаря этому один и тот же сценарий можно затем переиспользовать из разных «точек входа», не копируя логику между контроллерами, воркерами и консольными командами.

### 4.4 Преимущества для администрирования

В эксплуатации сервисный слой полезен тем, что операционные действия можно оформить как формализованные прикладные сценарии: пересчёт показателей, повтор фоновых задач, прогрев кэша, массовые корректировки и другие регламентные операции становятся частью приложения с предсказуемым поведением. Это уменьшает зависимость от «ручных» скриптов, которые часто живут отдельно от системы контроля версий, имеют слабые гарантии проверок и могут выполняться непоследовательно.

Когда административные действия проходят через единый слой сценариев, проще обеспечить контроль доступа, аудит и повторяемость: становится понятнее, кто запустил операцию, какие параметры использовались и что именно было сделано. Кроме того, сервисный слой удобно использовать как основу для административных эндпоинтов или CLI‑команд: при смене способа запуска меняется только слой доставки (HTTP/CLI), а логика операции остаётся единой.

### 4.5 Недостатки и антипаттерны

Один из главных рисков – God-service: сервисный класс разрастается, концентрируя слишком много сценариев и разнородной логики, из‑за чего ухудшаются читаемость, тестируемость и предсказуемость изменений (правки в одном месте начинают затрагивать несвязанные функции). Такой сервис становится «центральной точкой боли», потому что его трудно разделять, рефакторить и сопровождать без регрессий.

Вторая типовая проблема – дублирование доменной логики в сервисном слое: правила, которые должны быть инвариантами доменной модели, копируются в нескольких методах сервиса, и со временем эти копии начинают расходиться. Чтобы избежать этого, сервисный слой разумно удерживать в роли оркестратора сценариев (координация шагов, транзакции, вызовы репозиториев и интеграций), а бизнес‑инварианты и правила – фиксировать в доменной модели, оставляя сервису сквозные аспекты выполнения.

Набор практических критериев:

- Service Layer не должен содержать транспортных деталей (HTTP‑статус‑коды, заголовки, парсинг запроса/ответа, привязку к фреймворку) - иначе транспортный слой «протекает» в прикладную логику и сервисы сложно переиспользовать между HTTP/очередями/CLI.

- Методы сервиса должны описывать use-case и координацию шагов (вызовы доменных операций, репозиториев, интеграций) и быть основной точкой входа сценария - если контроллеры/хендлеры повторяют шаги сценария, значит use-case логика расползлась из сервисного слоя.

- Service Layer не должен превращаться в God-service – если один класс покрывает слишком много несвязанных операций и постоянно растёт, нарушены границы ответственности, и сервис нужно дробить по поддоменам/сценариям

- В Service Layer не должно быть дублирования доменных правил (инвариантов, допустимых переходов состояний) – если правило повторяется в нескольких сервисных методах, доменная логика «переехала» в оркестрацию и со временем начнёт расходиться.

- Service Layer не должен зависеть от деталей хранения – если сервису приходится «знать» про ORM, значит граница между сервисным слоем и слоем данных нарушена.

## 5 DTO (Data Transfer Object)

### 5.1 Определение и назначение

DTO (Data Transfer Object) – это объект (структура данных), предназначенный для передачи информации между слоями приложения или между различными подсистемами, чаще всего в виде, удобном для сериализации (JSON/XML/MessagePack и т.п.).

Ключевая идея DTO – отделить «контракт обмена данными» от внутренней доменной модели, чтобы изменения в бизнес‑логике и структуре доменных сущностей не ломали клиентов и интеграции напрямую.

DTO также помогает явно определить, какие поля вообще разрешено принимать/отдавать наружу, что снижает риск случайной утечки внутренних данных и упрощает контроль форматов на границе.

### 5.2 DTO на границах

На уровне HTTP API DTO обычно выступает в роли модели запроса (Request DTO) и модели ответа (Response DTO): первая описывает, какие данные клиент обязан/может прислать, а вторая – что именно и в каком виде возвращает система.

В событийно‑ориентированной архитектуре DTO часто используется как payload события (Event DTO): сообщение должно быть самодостаточным и стабильным, потому что его могут читать разные потребители и не всегда синхронно по времени.

Для интеграционных контрактов между сервисами DTO – фактически становится «языком общения» систем: чем яснее и стабильнее этот язык, тем меньше стоимость сопровождения и согласования изменений между командами.

### 5.3 Маппинг DTO и доменная модель (Mapper/Assembler)

Почти всегда DTO и доменная модель не совпадают один в один, потому что у них разные цели: доменная модель оптимизирована под бизнес‑правила и инварианты, а DTO – под обмен данными и контракт. Поэтому вводят маппинг (преобразование): из входного DTO создаются доменные объекты или параметры прикладной операции, а из результата доменной/прикладной логики собирается выходной DTO. Подход Mapper/Assembler подразумевает, что преобразование выполняется в выделенном месте (функции/класс/модуль), чтобы не «размазывать» конвертацию по контроллерам и сервисам и не смешивать транспортный контракт с бизнес‑логикой. Практически это повышает прозрачность границы: видно, какие поля являются частью внешнего контракта, какие вычисляются внутри, какие берутся из доменной модели, а какие намеренно скрываются.

### 5.4 Преимущества для администрирования и эксплуатации

Для эксплуатационных задач DTO полезен как стандартизированный формат «операционной команды»: например, для запуска пересчёта можно определить DTO с параметрами периода, режима обработки, лимитов и флагов безопасности, вместо неформальных аргументов в скриптах. Такая стандартизация повышает повторяемость: одинаковая операция при одинаковом DTO‑входе ведёт себя предсказуемо, что особенно важно при инцидентах и ручных восстановительных действиях.

DTO также удобно применять для аудита и логирования: когда вход/выход операции имеет строгую структуру, проще писать однородные журналы событий, строить метрики и проводить разбор «кто/что/когда запустил» без ручной интерпретации разрозненных логов.

Наконец, стабильные форматы DTO упрощают поддержку административных интерфейсов: один и тот же контракт можно использовать в админ‑панели, CLI‑утилите и внутреннем API, меняя только «доставку», а не смысл данных.

### 5.5 Риски DTO

Частая проблема – «взрыв» количества DTO: если делать отдельный класс на каждый частный случай без правил именования и структуры, проект обрастает сотнями похожих моделей, и навигация/сопровождение ухудшаются.

Второй риск связан с версионированием контрактов: DTO на границе является обещанием клиентам, поэтому изменения формата (переименование полей, изменение типов, изменение обязательности) требуют дисциплины совместимости или явного ввода версий (например, v1/v2).

Третий риск - дублирование полей и смыслов между DTO и доменной моделью: маппинг становится дорогим, появляется риск рассинхронизации (в домене правило изменили, а в DTO/маппинге забыли отразить), и в итоге система начинает вести себя непоследовательно.

Набор практических критериев:

- DTO должны быть «контрактом», а не отражением внутренней доменной/ORM‑модели: если наружу утекают доменные сущности или ORM‑entity (и клиенты зависят от их структуры), граница слоёв нарушена.

- В DTO не должно быть бизнес‑логики и поведения: если в DTO появляются методы с правилами вроде “можно ли оформить заказ”, “какая скидка применима”, “допустим ли переход состояния”, ответственность уехала из домена/Service Layer в транспортные структуры.

- DTO должны быть минимальными и целевыми: если один «универсальный» DTO используется для десятков разных сценариев и содержит множество необязательных полей “на всякий случай”, контракт становится размытым и начинает провоцировать ошибки валидации и интеграций.

- Маппинг DTO и доменная модель должны быть явными и централизованными: если преобразования разбросаны по контроллерам, сервисам и репозиториям, граница становится непрозрачной и повышается риск рассинхронизации полей.

- Изменения DTO должны контролироваться как изменения публичного API/контракта: если поля переименовываются/удаляются без стратегии совместимости (или без версионирования), клиенты и интеграции будут ломаться при релизах.

## 6 Совместное применение паттернов (FastAPI + SQLAlchemy)

### 6.1 Сквозной сценарий

Рассмотрим сценарий «Запуск админ‑операции пересчёта статистики» через отдельный endpoint /admin/stats/recalc. Для эксплуатации этот сценарий важен тем, что должен быть повторяемым, контролируемым по правам, и не должен зависеть от того, запускается ли он через HTTP, CLI или background worker.

В терминах паттернов это означает следующее: DTO фиксируют вход/выход операции как контракт, Service Layer оформляет пересчёт как use-case, а Repository изолирует SQLAlchemy и доступ к данным, чтобы сценарий не зависел от конкретных запросов и схемы хранения.

### 6.2 Поток: от Controller/API к выходной DTO

Полный поток: Controller/API → входной DTO→Service Layer→Repository→ выходной DTO

В FastAPI «контроллером» выступает endpoint-функция, которая принимает входную модель (DTO), получает зависимости через DI и возвращает объект, соответствующий выходной модели; формат ответа можно закрепить через response_model (это поддерживает идею DTO на границе).

#### 1. DTO(Pydantic) – контракт границы

```python
# dto.py

from pydantic import BaseModel, Field
from datetime import date
from typing import List, Optional
from uuid import UUID

class RecalcStatsRequestDTO(BaseModel):
    date_from: date
    date_to: date
    dry_run: bool = False
    reason: Optional[str] = Field(default=None, max_length=200)

class RecalcStatsResultDTO(BaseModel):
    run_id: UUID
    processed: int
    updated: int
    warnings: List[str] = []
```

#### 2. Repository – интерфейс + реализация на SQLAlchemy

```python
# repositories.py

from typing import Protocol, Iterable
from datetime import date

class OrdersRepository(Protocol):
    def iter_orders_in_range(self, date_from: date, date_to: date) -> Iterable[dict]:
        ...

class StatsRepository(Protocol):
    def upsert_daily_stat(self, day: date, value: int) -> None:
        ...

# sqlalchemy_repositories.py

from sqlalchemy.orm import Session
from sqlalchemy import select

class SqlAlchemyOrdersRepository:
    def __init__(self, session: Session):
        self.session = session

    def iter_orders_in_range(self, date_from, date_to):
        # Здесь SQLAlchemy-запросы; наружу не отдаём Query/Session
        stmt = select(Order).where(Order.created_at >= date_from,
                                   Order.created_at < date_to)
        for row in self.session.execute(stmt).scalars():
            yield {"id": row.id, "created_at": row.created_at, "amount": row.amount}

class SqlAlchemyStatsRepository:
    def __init__(self, session: Session):
        self.session = session

    def upsert_daily_stat(self, day, value):
        # Например: найти запись за день, обновить или вставить
        ...
```

#### 3. Service Layer – use-case/оркестрация

```python
# services.py

from uuid import uuid4
from collections import defaultdict

class StatsAdminService:
    def __init__(self, orders_repo, stats_repo, audit_writer):
        self.orders_repo = orders_repo
        self.stats_repo = stats_repo
        self.audit_writer = audit_writer

    def recalculate(self, dto: RecalcStatsRequestDTO, *, actor_id: str) -> RecalcStatsResultDTO:
        # 1) Политики доступа (проверка actor_id/роли) --- уровень сценария
        # 2) Валидация диапазона (например, date_from <= date_to, лимит периода)
        
        # 3) Чтение данных через репозиторий
        counters = defaultdict(int)
        processed = 0
        
        for order in self.orders_repo.iter_orders_in_range(dto.date_from, dto.date_to):
            processed += 1
            day = order["created_at"].date()
            counters[day] += 1
        
        # 4) Запись результата (или dry_run)
        updated = 0
        if not dto.dry_run:
            for day, value in counters.items():
                self.stats_repo.upsert_daily_stat(day, value)
                updated += 1
        
        # 5) Аудит операции (кто запустил, параметры, итог)
        run_id = uuid4()
        self.audit_writer.write(
            run_id=run_id,
            actor_id=actor_id,
            date_from=dto.date_from,
            date_to=dto.date_to,
            dry_run=dto.dry_run,
            reason=dto.reason,
            processed=processed,
            updated=updated,
        )
        
        return RecalcStatsResultDTO(run_id=run_id, processed=processed, updated=updated, warnings=[])
```

#### 4. FastAPI endpoint – доставка и связывание зависимостей

```python
# api_admin.py

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

router = APIRouter(prefix="/admin")

def get_db_session() -> Session:
    ...

def get_service(session: Session = Depends(get_db_session)) -> StatsAdminService:
    orders_repo = SqlAlchemyOrdersRepository(session)
    stats_repo = SqlAlchemyStatsRepository(session)
    audit_writer = ...
    return StatsAdminService(orders_repo, stats_repo, audit_writer)

def get_current_admin_id() -> str:
    ...

@router.post("/stats/recalc", response_model=RecalcStatsResultDTO)
def recalc_stats(dto: RecalcStatsRequestDTO,
                 service: StatsAdminService = Depends(get_service),
                 admin_id: str = Depends(get_current_admin_id)):
    return service.recalculate(dto, actor_id=admin_id)
```
Логика разделения здесь следующая: endpoint ничего «не считает» и не знает о SQLAlchemy, сервис ничего не знает про HTTP и формат ответа, а репозитории ничего не знают про бизнес-сценарий (они только читают/пишут данные).

### 6.3 Границы ответственности и критерии выбора

Service Layer становится обязательным, когда сценарий включает больше одного шага и требует координации: несколько репозиториев, транзакционная граница, внешние интеграции, проверки прав, формирование отчёта, ретраи или идемпотентность. В таких случаях размещение логики в контроллере быстро приводит к дублированию (особенно если тот же сценарий потом понадобится в CLI или фоновой задаче).

Repository оправдан, когда хочется защитить прикладной код от деталей SQLAlchemy: жизненного цикла Session, нюансов запросов, стратегий загрузки, оптимизаций, схемы таблиц и миграций. Репозиторий полезен и тогда, когда планируется активное тестирование сервисного слоя: проще подменить репозиторий фейком, чем поднимать тестовую БД для каждого unit-теста.

DTO почти всегда обязательны на границах приложения: входные DTO защищают от «лишних» полей и задают формат валидации, выходные DTO предотвращают утечки внутренних полей и фиксируют контракт для клиентов и админ-инструментов. В FastAPI это обычно оформляют через Pydantic-модели запроса/ответа и закрепляют выходной контракт через response_model.

## 7 Заключение

Паттерны Repository, Service Layer и DTO в совокупности дают практический способ выстроить слоистую архитектуру приложения так, чтобы она оставалась поддерживаемой при росте функциональности и числа интеграций. Их грамотное применение повышает устойчивость системы к «расползанию» ответственности между слоями и снижает стоимость изменений за счёт более чётких границ и предсказуемых контрактов.

В ходе рассмотрения темы были выделены ключевые роли каждого паттерна: Repository изолирует доступ к данным и скрывает инфраструктурные детали хранения, Service Layer формирует набор прикладных операций (use-case) и координирует выполнение сценариев, а DTO фиксирует формат передачи данных на границах между слоями и подсистемами. В связке эти подходы позволяют удерживать контроллеры «тонкими», концентрировать сценарии в одном месте и избегать протекания ORM/инфраструктуры в бизнес-код, что особенно важно для тестируемости и сопровождаемости.

Важно понимать место этих паттернов в общей архитектуре: они не являются самоцелью и не заменяют необходимость корректного доменного моделирования, качественного проектирования API и дисциплины работы с зависимостями. Repository, Service Layer и DTO наиболее эффективны, когда используются как средства разделения ответственности и стабилизации границ, а не как формальная «прослойка» ради прослойки.

Эффективность подхода напрямую зависит от аккуратности реализации и сопровождения: если DTO начинают содержать бизнес-логику, сервисы – HTTP-детали, а репозитории – правила предметной области, архитектурные границы размываются и преимущества быстро теряются. Для эксплуатационного контура особенно значимо оформлять административные операции как явные сценарии сервисного слоя и задавать для них стабильные DTO-контракты, чтобы обеспечить повторяемость действий, аудит и управляемость.

В дальнейшем, по мере усложнения системы и роста числа интеграций, архитектуру нередко приходится усиливать дополнительными практиками: более строгими правилами организации модулей, едиными соглашениями по контрактам и версионированию API, стандартизацией ошибок и логирования, а также повышением дисциплины в разграничении ответственности между слоями. Однако даже без таких расширений базовая связка Repository + Service Layer + DTO уже создаёт прочный фундамент для разработки и администрирования приложений, потому что фиксирует границы между доступом к данным, прикладными сценариями и транспортными контрактами. Это особенно заметно на стеке FastAPI + SQLAlchemy, где стабильные DTO‑контракты и изоляция ORM‑деталей позволяют поддерживать систему предсказуемо и безопасно при регулярных изменениях.

## 8 Список литературы

1.  Service Layer (Сервисный уровень) \[Электронный ресурс\]. – URL: <https://design-pattern.ru/patterns/service-layer.html> (дата обращения: 09.01.2026).

2.  Data Transfer Object (Объект передачи данных) \[Электронный ресурс\]. – URL: <https://design-pattern.ru/patterns/data-transfer-object.html> (дата обращения: 09.01.2026).

3.  Паттерн «Репозиторий». Основы и разъяснения \[Электронный ресурс\] // Habr. – 2016. – URL: https://habr.com/ru/articles/248505/ (дата обращения: 11.01.2026).

4.  Скользящая ответственность паттерна «Репозиторий» \[Электронный ресурс\] // Habr. – 2016. – URL: https://habr.com/ru/articles/304824/ (дата обращения: 11.01.2026).

5.  Проектирование сервисного слоя и логики приложения \[Электронный ресурс\]. – 2019. – URL: <https://emacsway.github.io/ru/service-layer/> (дата обращения: 12.01.2026).

6.  Repository Pattern (глава книги «Cosmic Python») \[Электронный ресурс\]. – URL: https://www.cosmicpython.com/book/chapter_02_repository.html (дата обращения: 11.01.2026).).

7.  Data Transfer Objects and Data Access Objects in Python with FastAPI \[Электронный ресурс\]. – 2023. – URL: <https://andrewfavia.dev/posts/dto-and-dao-fastapi/> (дата обращения: 18.01.2026).

8.  Луковичная архитектура в компоновке backend-приложений \[Электронный ресурс\] // Habr. – 2022. – URL: https://habr.com/ru/articles/672328/ (дата обращения: 17.01.2026).

9.  Модель ответа – Возвращаемый тип (FastAPI) \[Электронный ресурс\]. – URL: https://fastapi.tiangolo.com/ru/tutorial/response-model/ (дата обращения: 18.01.2026)

10. APIRouter class (FastAPI) \[Электронный ресурс\]. – URL: https://fastapi.tiangolo.com/reference/apirouter/ (дата обращения: 18.01.2026).

Реферат размещен по ссылке: <https://github.com/AIS-439/Stepanov_Valerij_Nikolaevich_27>


